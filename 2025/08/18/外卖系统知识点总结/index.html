<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="chenjunda"><meta name="renderer" content="webkit"><meta name="copyright" content="chenjunda"><meta name="keywords" content="陈小达的个人博客"><meta name="description" content="学习笔记"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>测试基础 · 陈小达的博客</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/cat.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">chenjunda</div><div class="profile-signature">长期主义</div><div class="friends"><div>FRIENDS</div><span><a href="//github.com/Longlongyu" target="_black">friendA</a></span><span><a href="//github.com/" target="_black">friendB</a></span><span><a href="//github.com/" target="_black">friendC</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">陈小达的博客</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">测试基础</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2025-08-18</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="测试"> 测试</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><span id="more"></span>

<h1 id="1-什么是软件测试？"><a href="#1-什么是软件测试？" class="headerlink" title="1.什么是软件测试？"></a>1.什么是软件测试？</h1><p>编写测试用例来发现bug，然后提交到开发，循环往复发现更多bug</p>
<h1 id="2-你知道的项目开发模型都有什么？"><a href="#2-你知道的项目开发模型都有什么？" class="headerlink" title="2.你知道的项目开发模型都有什么？"></a>2.你知道的项目开发模型都有什么？</h1><h2 id="2-1瀑布模型"><a href="#2-1瀑布模型" class="headerlink" title="2.1瀑布模型"></a>2.1瀑布模型</h2><p>是从 需求分析——计划——设计——编码——测试——end 这样的线性模型</p>
<h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><h4 id="1-强调开发的阶段性"><a href="#1-强调开发的阶段性" class="headerlink" title="1. 强调开发的阶段性"></a>1. <strong>强调开发的阶段性</strong></h4><ul>
<li>瀑布模型把整个开发流程拆分为 <strong>需求 → 设计 → 编码 → 测试 → 交付 → 维护</strong> 等阶段。</li>
<li>每个阶段都有明确的<strong>输入和输出</strong>，就像流水线一样一步一步推进。<br> 👉 好处：项目成员知道自己当前在做哪一环，责任清晰，不会混乱。</li>
</ul>
<hr>
<h4 id="2-强调早期计划及需求调查"><a href="#2-强调早期计划及需求调查" class="headerlink" title="2. 强调早期计划及需求调查"></a>2. <strong>强调早期计划及需求调查</strong></h4><ul>
<li>在开始写代码前，瀑布模型要求先把<strong>需求分析、系统设计、计划排期</strong>都弄清楚。</li>
<li>比如：要开发一个“机票预定系统”，在写代码前，就要明确用户能查航班、订票、退票，后台要支持支付、报表等。<br> 👉 好处：需求前期定得比较完整，开发过程中<strong>少走弯路</strong>，避免边写边改。</li>
</ul>
<hr>
<h4 id="3-强调产品测试"><a href="#3-强调产品测试" class="headerlink" title="3. 强调产品测试"></a>3. <strong>强调产品测试</strong></h4><ul>
<li>瀑布模型认为“测试”是一个独立的阶段，在编码完成后，必须<strong>系统性地测试</strong>整个产品。</li>
<li>这样可以保证最终交付的产品<strong>符合需求、质量可靠</strong>。<br> 👉 好处：保证上线前尽可能减少 bug，提高可信度</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>依赖于早期进行的唯一一次需求调查，不能适应需求的变化。</li>
<li>由于是单一流程，开发中的经验教训不能反馈应用于本产品的过程。</li>
<li>风险往往迟至后期的测试阶段才显露，因而失去及早纠正的机会。</li>
</ul>
<h2 id="2-2螺旋模型"><a href="#2-2螺旋模型" class="headerlink" title="2.2螺旋模型"></a>2.2螺旋模型</h2><ul>
<li><strong>思路</strong>：在迭代开发的基础上，<strong>每一轮迭代都包含风险分析和评估</strong>，就像螺旋一样一圈一圈往外扩展。</li>
<li><strong>特点</strong>：<ul>
<li>每个迭代周期包括：目标确定 → 风险分析 → 开发实现 → 评估计划。</li>
<li>强调 <strong>风险驱动</strong>，特别适合<strong>规模大、风险高</strong>的项目。</li>
<li>成本较高，因为需要不断进行风险评估和验证。</li>
</ul>
</li>
<li><strong>重点</strong>：强调 <strong>风险控制和评估</strong>，不是单纯的分功能做，而是每次都先“想清楚、评估风险”，再开发。</li>
</ul>
<p>👉 例子：做一个航空管制系统（高风险项目）</p>
<ul>
<li>第一次迭代：确定核心功能（航班调度），分析风险（实时性要求高、硬件兼容性），做原型验证。</li>
<li>第二次迭代：扩展功能（应急处理），再做风险评估（数据丢失风险），继续实现。</li>
<li>迭代中持续评估和优化，避免高风险导致失败。</li>
</ul>
<h2 id="2-3-增量迭代模型"><a href="#2-3-增量迭代模型" class="headerlink" title="2.3. 增量迭代模型"></a>2.3. <strong>增量迭代模型</strong></h2><ul>
<li><strong>思路</strong>：把系统分成多个<strong>小功能模块（增量）</strong>，逐个开发，每次开发完成一个可用子系统，然后逐步叠加，直到形成完整系统。</li>
<li><strong>特点</strong>：<ul>
<li>每个迭代都能交付一个<strong>可运行的部分产品</strong>。</li>
<li>用户能较早用上部分功能，逐步完善。</li>
<li>适合需求较明确、但系统较复杂的项目。</li>
</ul>
</li>
<li><strong>重点</strong>：强调 <strong>功能分批实现</strong>，像“拼积木”。</li>
</ul>
<p>👉 例子：做一个电商网站</p>
<ul>
<li>第一次迭代：用户注册&#x2F;登录</li>
<li>第二次迭代：商品浏览</li>
<li>第三次迭代：购物车</li>
<li>第四次迭代：下单支付<br> 这样一步一步上线，逐渐变完整。</li>
</ul>
<h2 id="2-4敏捷模型"><a href="#2-4敏捷模型" class="headerlink" title="2.4敏捷模型"></a>2.4敏捷模型</h2><p>敏捷模型和增量迭代模型确实看起来很像，因为 <strong>它们都不是“一次性大交付”，而是分阶段交付</strong>。但它们之间有几个关键差别：</p>
<hr>
<h2 id="🔑-共同点"><a href="#🔑-共同点" class="headerlink" title="🔑 共同点"></a>🔑 共同点</h2><ul>
<li>都是 <strong>分阶段逐步交付产品</strong>，不是瀑布那种一次性交付。</li>
<li>用户能 <strong>较早看到部分成果</strong>，并且随着迭代逐渐完善系统。</li>
</ul>
<hr>
<h2 id="🚩-区别"><a href="#🚩-区别" class="headerlink" title="🚩 区别"></a>🚩 区别</h2><table>
<thead>
<tr>
<th>对比点</th>
<th><strong>增量迭代模型</strong></th>
<th><strong>敏捷模型</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>目标</strong></td>
<td>按功能分块，逐步实现，直到完整系统</td>
<td>快速响应变化，持续交付价值</td>
</tr>
<tr>
<td><strong>迭代驱动</strong></td>
<td>以功能模块为主（例如：登录 → 浏览 → 下单）</td>
<td>以用户价值和反馈为主（客户最想要什么功能，就先做）</td>
</tr>
<tr>
<td><strong>需求变化</strong></td>
<td>初期需求相对明确，变化不大</td>
<td>默认需求会变，随时可以调整</td>
</tr>
<tr>
<td><strong>用户参与</strong></td>
<td>用户主要在增量交付后验证结果</td>
<td>用户贯穿整个过程，持续参与每个迭代</td>
</tr>
<tr>
<td><strong>团队方式</strong></td>
<td>强调分阶段开发，流程相对正式</td>
<td>强调小团队、自组织、频繁沟通（Scrum 每日站会）</td>
</tr>
<tr>
<td><strong>交付节奏</strong></td>
<td>交付可能按大功能块划分，周期相对长</td>
<td>短周期（2~4 周）就交付一个可用的版本</td>
</tr>
<tr>
<td><strong>管理理念</strong></td>
<td>偏传统：先计划好各个增量，然后按部就班实现</td>
<td>偏灵活：先做最有价值的功能，随时根据反馈调整计划</td>
</tr>
</tbody></table>
<hr>
<h2 id="📌-类比理解"><a href="#📌-类比理解" class="headerlink" title="📌 类比理解"></a>📌 类比理解</h2><ul>
<li><strong>增量迭代模型</strong>：像盖房子，先盖好一层 → 再盖二层 → 再盖三层，最后盖成完整的楼。</li>
<li><strong>敏捷模型</strong>：像做蛋糕，先做一个小的可以吃的蛋糕 → 客户尝一口说“太甜了” → 下一次做得没那么甜 → 再下一次加点水果装饰。每次交付的东西都是<strong>完整可用</strong>的。</li>
</ul>
<hr>
<p>✅ <strong>一句话总结</strong>：</p>
<ul>
<li><strong>增量迭代</strong>：强调“怎么分功能逐步实现”。</li>
<li><strong>敏捷</strong>：强调“快速交付、持续反馈、灵活应对变化”。</li>
</ul>
<h1 id="3-什么是测试左移，测试右移"><a href="#3-什么是测试左移，测试右移" class="headerlink" title="3.什么是测试左移，测试右移"></a>3.什么是测试左移，测试右移</h1><p>如果把软件开发过程画在时间线上：<br> <strong>需求 → 设计 → 开发 → 测试 → 运维&#x2F;上线</strong><br> 那么：</p>
<ul>
<li><strong>左边</strong>代表开发早期阶段（需求、设计）。</li>
<li><strong>右边</strong>代表开发后期阶段（上线、运维）。</li>
</ul>
<hr>
<h2 id="🔹-测试左移（Shift-Left-Testing）"><a href="#🔹-测试左移（Shift-Left-Testing）" class="headerlink" title="🔹 测试左移（Shift Left Testing）"></a>🔹 测试左移（Shift Left Testing）</h2><ul>
<li><strong>含义</strong>：把测试活动提前（往左边）放，在需求、设计、开发阶段就介入测试，而不是等到“开发完了再测”。</li>
<li><strong>做法</strong>：<ul>
<li>在需求阶段做需求评审，尽早发现需求歧义。</li>
<li>在设计阶段做静态检查、代码走查。</li>
<li>在开发阶段就开始单元测试、持续集成。</li>
</ul>
</li>
<li><strong>目的</strong>：<ul>
<li><strong>尽早发现缺陷，降低修复成本</strong>（越早发现 bug，修复成本越低）。</li>
</ul>
</li>
<li><strong>例子</strong>：写代码的同时写单元测试，或者在功能还没开发完时就准备好自动化测试用例。</li>
</ul>
<p>👉 <strong>一句话</strong>：<strong>提前测试，问题越早暴露越便宜。</strong></p>
<hr>
<h2 id="🔹-测试右移（Shift-Right-Testing）"><a href="#🔹-测试右移（Shift-Right-Testing）" class="headerlink" title="🔹 测试右移（Shift Right Testing）"></a>🔹 测试右移（Shift Right Testing）</h2><ul>
<li><strong>含义</strong>：把测试活动延伸到系统上线&#x2F;运维阶段（往右边移动）。</li>
<li><strong>做法</strong>：<ul>
<li>在生产环境或接近生产的环境做测试。</li>
<li>使用 A&#x2F;B 测试、灰度发布、金丝雀发布。</li>
<li>用监控、日志、用户行为分析来发现问题。</li>
</ul>
</li>
<li><strong>目的</strong>：<ul>
<li><strong>保证真实环境下的质量和用户体验</strong>，并快速发现和修复生产中的问题。</li>
</ul>
</li>
<li><strong>例子</strong>：上线时先让 5% 用户使用新功能（灰度），收集日志和反馈，确认稳定后再扩大范围。</li>
</ul>
<p>👉 <strong>一句话</strong>：<strong>上线后也不停测试，保证真实环境下的质量。</strong></p>
<hr>
<h2 id="📌-对比总结"><a href="#📌-对比总结" class="headerlink" title="📌 对比总结"></a>📌 对比总结</h2><table>
<thead>
<tr>
<th>对比点</th>
<th><strong>测试左移</strong></th>
<th><strong>测试右移</strong></th>
</tr>
</thead>
<tbody><tr>
<td><strong>位置</strong></td>
<td>开发早期（需求&#x2F;设计&#x2F;开发）</td>
<td>开发后期（上线&#x2F;运维）</td>
</tr>
<tr>
<td><strong>目标</strong></td>
<td>提前发现缺陷，降低修复成本</td>
<td>保证真实环境质量，优化用户体验</td>
</tr>
<tr>
<td><strong>常见方式</strong></td>
<td>需求评审、静态分析、单元测试、持续集成</td>
<td>灰度发布、A&#x2F;B 测试、监控、日志分析</td>
</tr>
<tr>
<td><strong>核心理念</strong></td>
<td><strong>尽早预防</strong></td>
<td><strong>持续验证</strong></td>
</tr>
</tbody></table>
<hr>
<p>✅ <strong>一句话总结</strong>：</p>
<ul>
<li><strong>测试左移</strong> &#x3D; 把测试往前挪，尽早发现问题。</li>
<li><strong>测试右移</strong> &#x3D; 把测试往后延，关注上线后用户体验和真实运行质量。</li>
</ul>
<h1 id="4-你知道的测试设计用例方法有哪些？"><a href="#4-你知道的测试设计用例方法有哪些？" class="headerlink" title="4.你知道的测试设计用例方法有哪些？"></a>4.你知道的测试设计用例方法有哪些？</h1><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/CYK_byte/article/details/128601439?ops_request_misc=&request_id=&biz_id=102&utm_term=%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%B8%87%E8%83%BD%E5%85%AC%E5%BC%8F&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-0-128601439.nonecase&spm=1018.2226.3001.4450">https://blog.csdn.net/CYK_byte/article/details/128601439?ops_request_misc=&amp;request_id=&amp;biz_id=102&amp;utm_term=%E8%AE%BE%E8%AE%A1%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E4%B8%87%E8%83%BD%E5%85%AC%E5%BC%8F&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~blog~sobaiduweb~default-0-128601439.nonecase&amp;spm=1018.2226.3001.4450</a></p>
<h1 id="5-什么是埋点测试？"><a href="#5-什么是埋点测试？" class="headerlink" title="5.什么是埋点测试？"></a>5.什么是埋点测试？</h1><p>​	埋点测试是指在应用程序（如网站、移动应用等）中特定的位置插入代码，用于<strong>收集用户行为数据</strong>的过程。这些插入的代码就像一个个“监测点”，可以<strong>捕捉用户在应用内的各种操作和行为</strong>，例如点击按钮、浏览页面、提交表单等，以便后续对这些数据进行分析，了解用户的使用习惯、行为路径等，从而<strong>为产品优化、业务决策等提供数据支持</strong>。</p>
<h2 id="一-埋点类型"><a href="#一-埋点类型" class="headerlink" title="一.埋点类型"></a>一.埋点类型</h2><p>**代码埋点：**开发人员通过在需要收集数据的地方手动编写代码来实现埋点。这种方式灵活性高，可以精确地控制收集哪些数据以及在何时收集，但缺点是开发工作量较大，且如果需求变更，可能需要修改大量代码。</p>
<p>**可视化埋点：**通过可视化工具，无需编写大量代码，开发人员或运营人员可以直接在界面上选择需要埋点的元素，配置相关的数据收集规则。它的优点是操作相对简单、直观，能快速进行埋点部署，缺点是可能在某些复杂场景下灵活性不如代码埋点。</p>
<p>**无埋点：**通过特定的技术手段，自动收集应用程序中的所有用户行为数据，无需在代码中逐个添加埋点。这种方式可以收集到全面的数据，但可能会收集到一些无用的数据，增加了数据处理和分析的难度，并且对于一些特定的、复杂的业务逻辑数据收集可能不够精准。</p>
<h2 id=""><a href="#" class="headerlink" title=""></a></h2><h2 id="二-测试内容"><a href="#二-测试内容" class="headerlink" title="二.测试内容"></a>二.测试内容</h2><p>**数据准确性：**检查埋点所收集的数据是否准确无误，例如点击事件的记录是否与用户实际点击的位置和次数完全一致，页面浏览量的统计是否准确等。</p>
<p>**数据完整性：**验证是否所有需要收集的用户行为数据都被正确地记录下来，没有遗漏重要的操作或事件。</p>
<p>**埋点性能：**关注埋点代码对应用程序性能的影响，如是否会导致应用程序卡顿、加载速度变慢等问题。</p>
<h2 id="-1"><a href="#-1" class="headerlink" title=""></a></h2><h2 id="三-实施流程-面试官问起即可showtime"><a href="#三-实施流程-面试官问起即可showtime" class="headerlink" title="三.实施流程(面试官问起即可showtime)"></a>三.实施流程(面试官问起即可showtime)</h2><ol>
<li>需求分析：与产品、运营等团队沟通，明确需要收集哪些用户行为数据，以及这些数据将用于何种业务目的。</li>
<li>埋点设计：根据需求分析的结果，确定在应用程序的哪些页面、元素上进行埋点，以及每个埋点需要收集哪些具体的数据字段。</li>
<li>代码实现：开发人员按照埋点设计方案，在相应的代码位置插入埋点代码。</li>
<li>测试验证：对埋点进行全面的测试，确保数据的准确性、完整性等符合要求。</li>
<li>部署上线：经过测试无误后，将埋点代码部署到生产环境中，开始正式收集用户行为数据。</li>
<li>数据分析与应用：对收集到的数据进行分析，提取有价值的信息，为产品优化、运营决策等提供支持。</li>
</ol>
<h2 id="-2"><a href="#-2" class="headerlink" title=""></a></h2><h2 id="四-应用场景"><a href="#四-应用场景" class="headerlink" title="四.应用场景"></a>四.应用场景</h2><p><strong>产品优化</strong>：通过分析用户在应用内的行为路径、停留时间等数据，发现用户体验不佳的环节，从而对产品的界面设计、功能流程等进行优化。</p>
<p>**用户行为分析：**了解用户的使用习惯、偏好，为用户画像的构建提供数据基础，以便进行精准营销、个性化推荐等。</p>
<p>**业务指标监测：**实时监测业务关键指标，如订单转化率、用户活跃度等，及时发现业务问题，为决策提供数据支持。</p>
<h2 id="-3"><a href="#-3" class="headerlink" title=""></a></h2><h2 id="案列解读："><a href="#案列解读：" class="headerlink" title="案列解读："></a>案列解读：</h2><p>​	比如下面这是一份埋点数据的统计表，记录了多个埋点事件，通过统计埋点ID(属性)的次数，来得到一份具体的数据，例如B站的用户在观看视频的时候，可能会有一系列的行为操作如：拖动进度条，调整倍速，选择比例，切换画质等，用户的一系列操作会产生一定的数据，每一步点击&#x2F;滑动等操作的频次，对于公司的“数据分析师”来说是非常重要的数据指标，产品&#x2F;项目同学会依据这些数据来调整&#x2F;发掘需求和已有功能的优化等。</p>
<h1 id="6-什么是冒烟测试？"><a href="#6-什么是冒烟测试？" class="headerlink" title="6.什么是冒烟测试？"></a>6.什么是冒烟测试？</h1><h2 id="1-核心"><a href="#1-核心" class="headerlink" title="1.核心"></a>1.核心</h2><p>冒烟测试就是完成一个新版本的开发后，对该版本最基本的功能进行测试，保证基本的功能和流程能走通。</p>
<p>如果不通过，则打回开发那边重新开发；</p>
<p>如果通过测试，才会进行下一步的测试(功能测试，集成测试，系统测试等等)。</p>
<p>简化：门槛测试，一个开关而不是一个阶段。</p>
<p>目的：版本验证测试BVT（Build Verification Testing）。</p>
<p>时间：开发转测试，历时半至一个小时，很短。</p>
<p>对象：需求覆盖，主功能路径。</p>
<p>优点：节省测试时间，防止build失败。</p>
<p>缺点：覆盖率还是比较低。</p>
<p>操作：对着需求文档把新功能过一遍；把所有流程功能走一遍；用monkey跑个一两个小时；如果有历史用例的话，可以把用例分级，冒烟级、详细级、回归级等等</p>
<p>用例：冒烟测试基本上不需要什么用例，如果有的话，就用详细用例里，覆盖需求文档级别的用例就可以了</p>
<p>冒烟测试，是版本验证测试，主要确认新的版本是否存在致命性bug，冒烟测试最大的优点在于节约测试的时间成本，减少测试轮数。</p>
<p>回归测试，是软件维护阶段对软件修改后进行的测试，指修改了旧代码后，重新进行测试以确认修改没有引入新的错误或导致其他代码产生错误。</p>
<h2 id="2-定义"><a href="#2-定义" class="headerlink" title="2.定义"></a>2.定义</h2><p>冒烟测试这个名称的来历，最初是从电路板测试得来的。因为当电路板做好以后，首先会加电测试，如果板子没有冒烟再进行其它测试，否则就必须重新来过。</p>
<p>而在软件研发中，冒烟测试其实是微软首先提出来的一个概念，和微软一直提倡的每日build（构建版本）有很密切的联系。具体说，冒烟测试就是在每日build（构建版本）建立后，对系统的基本功能进行简单的测试。这种测试强调程序的主要功能进行的验证，而不会对具体功能进行更深入的测试。</p>
<p>冒烟只是这类测试活动更形象化一些的叫法，直接叫做BVT（Build Verification Testing）其实个人觉得更为贴切。</p>
<h2 id="3-WHY"><a href="#3-WHY" class="headerlink" title="3.WHY"></a>3.WHY</h2><p>为什么进行冒烟测试？软件测试从业者都知道，bug发现得越晚，修复bug的成本就越高。那成本高在哪里呢？</p>
<p>影响的代码多，开发的修复成本会增加</p>
<p>影响的功能范围较大，测试回归的范围增加</p>
<p>容易引发更多的bug，拉长测试周期，还有质量风险</p>
<p>更多的bug，会增加bug的提交、沟通成本</p>
<p>所以，如何尽早发现bug，把bug置解决是降低成本和控制止风险的有效方式，也是QA的主要职责之一。因此使用冒烟测试的方式，对开发提测的代码进行审查，找出那些非常浅显的bug是很有必要的</p>
<h2 id="4-特点"><a href="#4-特点" class="headerlink" title="4.特点"></a>4.特点</h2><p>(1) 这种测试强调程序的主要功能进行的验证，而不会对具体功能进行更深入的测试。</p>
<p>(2) 冒烟测试是随着版本转测进行的，它应该是一个开关(判断版本能否转测试)而不是一个研发流程中的测试阶段。</p>
<p>(3) 冒烟测试用例一般选取的是测试用例中level 0的用例，保证主功能可用。</p>
<p>(4) 冒烟测试就是在一个新版本出来的时候，将软件的全部功能过一遍，看有没有什么大问题。如果功能可以正常运行，不会影响测试进行，那么这个版本就可以真正开始测试了。如果功能有重大问题或影响测试进行，那么这个版本就是不合格的，不用进行进一步的测试。</p>
<h2 id="5-实现"><a href="#5-实现" class="headerlink" title="5.实现"></a>5.实现</h2><p>开展冒烟测试工作有助于尽早发现软件代码存在的问题，提高软件代码的质量和开发效率。</p>
<p>基于持续集成(Continuous Integration，CI)的冒烟测试采用自动化测试脚本进行测试工作，能够提高测试效率，减少测试人员大量的重复测试验证工作。</p>
<p>冒烟测试的最佳实践还是最好被自动化，在CI中每一个Build都自动的去执行主流程的测试，确保其是一个基本可用的版本。</p>
<p>冒烟测试可以手动执行，也可以自动化执行。稳定的系统适合自动化冒烟测试，集成过程中的系统适合手工冒烟测试，因为冒烟测试内容在动态变化，变化中的自动化脚本维护工作量比较大。</p>
<h2 id="6-案例选择原则"><a href="#6-案例选择原则" class="headerlink" title="6.案例选择原则"></a>6.案例选择原则</h2><p>既然只是个准入门槛那就不会选择全部案例进行测试，根据经验，选择全部案例数的 40%-50% 测试通过率在 80% 左右即可视为冒烟测试通过，允许测试准入，那这部分案例如何选择呢？</p>
<p>遵循以下原则</p>
<p>A选取重要功能案例。</p>
<p>重要功能案例至少应占冒烟案例的 30%，特别关注对软件功能实现具有重要影响的功能模块测试案例，例如：一个事件（业务）的增加、删除、修改、查询，一个统计、计算逻辑的的结果校验等。</p>
<p>B选取主要流程</p>
<p>主、分流程，对于主流程案例原则上应选取，分支流程案例可视其与主流程关联度和影响度从高到低选择部分。如主流程未通过，即使总案例通过率达到通过标准，该软件也应被拒绝准入，待开发人员修正后重新进入冒烟测试环节。例如：一个审批流程，即使增加、删除、修改、查询的功能均通过，但如果整个流程环节中出现阻塞，无法完成完整的审批，则应视为冒烟未通过。</p>
<p>C筛选数据案例</p>
<p>筛选与主流程、重要功能相关度高的数据测试案例，原则是确保数据的埋设满足主流程、重要功能测试条件。例如：想校验一个商品购买的正确性，就离不开商品种类、单位、库存、价格、购买数量等数据相关案例。这仅是一个简单的商品购买，如果是统计分析则更需要大量不同种类、不同时点的数据作为测试基础。</p>
</article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://example.com">chenjunda</a></p><p> <span>Link:  </span><a href="http://example.com/2025/08/18/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/">http://example.com/2025/08/18/%E5%A4%96%E5%8D%96%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2025/09/16/redis%E5%AD%A6%E4%B9%A0Day1/" title="redis学习Day1"><span>< PreviousPost</span><br><span class="prevTitle">redis学习Day1</span></a><a class="nextSlogan" href="/2025/08/03/%E8%8B%8D%E7%A9%B9%E5%A4%96%E5%8D%96day07/" title="苍穹外卖day07"><span>NextPost ></span><br><span class="nextTitle">苍穹外卖day07</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%80%E4%B9%88%E6%98%AF%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1.什么是软件测试？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91%E6%A8%A1%E5%9E%8B%E9%83%BD%E6%9C%89%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2.你知道的项目开发模型都有什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1%E7%80%91%E5%B8%83%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.1.</span> <span class="toc-text">2.1瀑布模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">2.1.1.</span> <span class="toc-text">优点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-%E5%BC%BA%E8%B0%83%E5%BC%80%E5%8F%91%E7%9A%84%E9%98%B6%E6%AE%B5%E6%80%A7"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">1. 强调开发的阶段性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-%E5%BC%BA%E8%B0%83%E6%97%A9%E6%9C%9F%E8%AE%A1%E5%88%92%E5%8F%8A%E9%9C%80%E6%B1%82%E8%B0%83%E6%9F%A5"><span class="toc-number">2.1.1.2.</span> <span class="toc-text">2. 强调早期计划及需求调查</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-%E5%BC%BA%E8%B0%83%E4%BA%A7%E5%93%81%E6%B5%8B%E8%AF%95"><span class="toc-number">2.1.1.3.</span> <span class="toc-text">3. 强调产品测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">2.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2%E8%9E%BA%E6%97%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">2.2螺旋模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-%E5%A2%9E%E9%87%8F%E8%BF%AD%E4%BB%A3%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.3.</span> <span class="toc-text">2.3. 增量迭代模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-4%E6%95%8F%E6%8D%B7%E6%A8%A1%E5%9E%8B"><span class="toc-number">2.4.</span> <span class="toc-text">2.4敏捷模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%91-%E5%85%B1%E5%90%8C%E7%82%B9"><span class="toc-number">2.5.</span> <span class="toc-text">🔑 共同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%9A%A9-%E5%8C%BA%E5%88%AB"><span class="toc-number">2.6.</span> <span class="toc-text">🚩 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E7%B1%BB%E6%AF%94%E7%90%86%E8%A7%A3"><span class="toc-number">2.7.</span> <span class="toc-text">📌 类比理解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E4%BB%80%E4%B9%88%E6%98%AF%E6%B5%8B%E8%AF%95%E5%B7%A6%E7%A7%BB%EF%BC%8C%E6%B5%8B%E8%AF%95%E5%8F%B3%E7%A7%BB"><span class="toc-number">3.</span> <span class="toc-text">3.什么是测试左移，测试右移</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9-%E6%B5%8B%E8%AF%95%E5%B7%A6%E7%A7%BB%EF%BC%88Shift-Left-Testing%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">🔹 测试左移（Shift Left Testing）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%94%B9-%E6%B5%8B%E8%AF%95%E5%8F%B3%E7%A7%BB%EF%BC%88Shift-Right-Testing%EF%BC%89"><span class="toc-number">3.2.</span> <span class="toc-text">🔹 测试右移（Shift Right Testing）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%93%8C-%E5%AF%B9%E6%AF%94%E6%80%BB%E7%BB%93"><span class="toc-number">3.3.</span> <span class="toc-text">📌 对比总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E4%BD%A0%E7%9F%A5%E9%81%93%E7%9A%84%E6%B5%8B%E8%AF%95%E8%AE%BE%E8%AE%A1%E7%94%A8%E4%BE%8B%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4.你知道的测试设计用例方法有哪些？</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BB%80%E4%B9%88%E6%98%AF%E5%9F%8B%E7%82%B9%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5.什么是埋点测试？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80-%E5%9F%8B%E7%82%B9%E7%B1%BB%E5%9E%8B"><span class="toc-number">5.1.</span> <span class="toc-text">一.埋点类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link"><span class="toc-number">5.2.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C-%E6%B5%8B%E8%AF%95%E5%86%85%E5%AE%B9"><span class="toc-number">5.3.</span> <span class="toc-text">二.测试内容</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-1"><span class="toc-number">5.4.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89-%E5%AE%9E%E6%96%BD%E6%B5%81%E7%A8%8B-%E9%9D%A2%E8%AF%95%E5%AE%98%E9%97%AE%E8%B5%B7%E5%8D%B3%E5%8F%AFshowtime"><span class="toc-number">5.5.</span> <span class="toc-text">三.实施流程(面试官问起即可showtime)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-2"><span class="toc-number">5.6.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.7.</span> <span class="toc-text">四.应用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#-3"><span class="toc-number">5.8.</span> <span class="toc-text"></span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A1%88%E5%88%97%E8%A7%A3%E8%AF%BB%EF%BC%9A"><span class="toc-number">5.9.</span> <span class="toc-text">案列解读：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%92%E7%83%9F%E6%B5%8B%E8%AF%95%EF%BC%9F"><span class="toc-number">6.</span> <span class="toc-text">6.什么是冒烟测试？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%A0%B8%E5%BF%83"><span class="toc-number">6.1.</span> <span class="toc-text">1.核心</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E5%AE%9A%E4%B9%89"><span class="toc-number">6.2.</span> <span class="toc-text">2.定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-WHY"><span class="toc-number">6.3.</span> <span class="toc-text">3.WHY</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E7%89%B9%E7%82%B9"><span class="toc-number">6.4.</span> <span class="toc-text">4.特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E5%AE%9E%E7%8E%B0"><span class="toc-number">6.5.</span> <span class="toc-text">5.实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%A1%88%E4%BE%8B%E9%80%89%E6%8B%A9%E5%8E%9F%E5%88%99"><span class="toc-number">6.6.</span> <span class="toc-text">6.案例选择原则</span></a></li></ol></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>