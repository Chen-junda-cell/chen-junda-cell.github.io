<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><meta name="author" content="chenjunda"><meta name="renderer" content="webkit"><meta name="copyright" content="chenjunda"><meta name="keywords" content="陈小达的个人博客"><meta name="description" content="学习笔记"><meta name="Cache-Control" content="no-cache"><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"><title>189.轮转数组 · 陈小达的博客</title><link rel="stylesheet" href="/css/style.css?v=2018.7.9"><link rel="stylesheet" href="/css/animation.css?v=2018.7.9"><link rel="icon" href="/img/assets/favicon.ico"><link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css?version=1.5.6"><!-- scripts--><script>(function( w ){
  "use strict";
  // rel=preload support test
  if( !w.loadCSS ){
    w.loadCSS = function(){};
  }
  // define on the loadCSS obj
  var rp = loadCSS.relpreload = {};
  // rel=preload feature support test
  // runs once and returns a function for compat purposes
  rp.support = (function(){
    var ret;
    try {
      ret = w.document.createElement( "link" ).relList.supports( "preload" );
    } catch (e) {
      ret = false;
    }
    return function(){
      return ret;
    };
  })();

  // if preload isn't supported, get an asynchronous load by using a non-matching media attribute
  // then change that media back to its intended value on load
  rp.bindMediaToggle = function( link ){
    // remember existing media attr for ultimate state, or default to 'all'
    var finalMedia = link.media || "all";

    function enableStylesheet(){
      link.media = finalMedia;
    }

    // bind load handlers to enable media
    if( link.addEventListener ){
      link.addEventListener( "load", enableStylesheet );
    } else if( link.attachEvent ){
      link.attachEvent( "onload", enableStylesheet );
    }

    // Set rel and non-applicable media type to start an async request
    // note: timeout allows this to happen async to let rendering continue in IE
    setTimeout(function(){
      link.rel = "stylesheet";
      link.media = "only x";
    });
    // also enable media after 3 seconds,
    // which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
    setTimeout( enableStylesheet, 3000 );
  };

  // loop through link elements in DOM
  rp.poly = function(){
    // double check this to prevent external calls from running
    if( rp.support() ){
      return;
    }
    var links = w.document.getElementsByTagName( "link" );
    for( var i = 0; i < links.length; i++ ){
      var link = links[ i ];
      // qualify links to those with rel=preload and as=style attrs
      if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
        // prevent rerunning on link
        link.setAttribute( "data-loadcss", true );
        // bind listeners to toggle media back
        rp.bindMediaToggle( link );
      }
    }
  };

  // if unsupported, run the polyfill
  if( !rp.support() ){
    // run once at least
    rp.poly();

    // rerun poly on an interval until onload
    var run = w.setInterval( rp.poly, 500 );
    if( w.addEventListener ){
      w.addEventListener( "load", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    } else if( w.attachEvent ){
      w.attachEvent( "onload", function(){
        rp.poly();
        w.clearInterval( run );
      } );
    }
  }


  // commonjs
  if( typeof exports !== "undefined" ){
    exports.loadCSS = loadCSS;
  }
  else {
    w.loadCSS = loadCSS;
  }
}( typeof global !== "undefined" ? global : this ) );</script><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" defer></script><script src="/js/main.js?v=2018.7.9" defer></script><!-- fancybox--><link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'"><script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script><!-- busuanzi--><script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script><meta name="generator" content="Hexo 7.3.0"></head><body><section class="profile-close" id="cxo-profile"><div class="profile-avatar"><i class="fa fa-caret-left"></i><img src="/img/assets/cat.png"></div><!--.profile-saying
  i.fa.fa-comment
  .saying--><div class="cxo-profile-inner"><div class="profile-name">chenjunda</div><div class="profile-signature">长期主义</div><div class="friends"><div>FRIENDS</div><span><a href="//github.com/Longlongyu" target="_black">friendA</a></span><span><a href="//github.com/" target="_black">friendB</a></span><span><a href="//github.com/" target="_black">friendC</a></span></div><div class="read-progress"></div></div></section><header id="cxo-intro" style="height: 70vh;background-image: url(/img/intro/index-bg.png);"><nav id="cxo-intro-nav"><section><div class="intro-nav-title"><a href="/">陈小达的博客</a></div><div class="intro-nav-label-box"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div><i class="fa fa-bars intro-nav-menu"><div class="intro-nav-drop"><a href="/">Home</a><a href="/about/">About</a><a href="/archives/">Archives</a><a href="/tags/">Tags</a></div></i><div class="clear"></div></section></nav><h1 class="post-title">189.轮转数组</h1><div class="post-intros"><div class="post-intro-meta"><span class="post-intro-time"><i class="post-intro-calendar fa fa-calendar"></i><span>2025-11-05</span></span><span class="post-intro-tags"><a class="intro-tag fa fa-tag" href="javascript:void(0)" date-tags="leecode Hot100"> leecode Hot100</a></span></div></div></header><article class="cxo-up" id="cxo-content-outer"><section id="cxo-content-inner"><article class="article-entry" id="post"><p>给定一个整数数组 <code>nums</code>，将数组中的元素向右轮转 <code>k</code> 个位置，其中 <code>k</code> 是非负数。</p>
<p><strong>示例 1:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,2,3,4,5,6,7], k = 3</span><br><span class="line">输出: [5,6,7,1,2,3,4]</span><br><span class="line">解释:</span><br><span class="line">向右轮转 1 步: [7,1,2,3,4,5,6]</span><br><span class="line">向右轮转 2 步: [6,7,1,2,3,4,5]</span><br><span class="line">向右轮转 3 步: [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p><strong>示例 2:</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,-100,3,99], k = 2</span><br><span class="line">输出：[3,99,-1,-100]</span><br><span class="line">解释: </span><br><span class="line">向右轮转 1 步: [99,-1,-100,3]</span><br><span class="line">向右轮转 2 步: [3,99,-1,-100]</span><br></pre></td></tr></table></figure>

<p><strong>提示：</strong></p>
<ul>
<li><code>1 &lt;= nums.length &lt;= 105</code></li>
<li><code>-231 &lt;= nums[i] &lt;= 231 - 1</code></li>
<li><code>0 &lt;= k &lt;= 105</code></li>
</ul>
<p>这题很巧妙，属于技巧题，基本思路就是使用双端队列k次循环来实现，但是有一种思路很巧妙可以实现空间复杂度为O（1）的方法</p>
<h2 id="💡-思路核心：三次反转法（Reverse-Algorithm）"><a href="#💡-思路核心：三次反转法（Reverse-Algorithm）" class="headerlink" title="💡 思路核心：三次反转法（Reverse Algorithm）"></a>💡 思路核心：<strong>三次反转法（Reverse Algorithm）</strong></h2><p>思考轮转的本质：<br> 向右轮转 <code>k</code> 位 &#x3D; 把 <strong>后 k 个元素</strong> 挪到前面。</p>
<p>也就是：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">原数组:    [1,2,3,4,5,6,7]</span><br><span class="line">分成两段:  [1,2,3,4] [5,6,7]</span><br><span class="line">轮转结果:  [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure>

<p>要原地完成这个操作，可以通过“反转”实现：</p>
<hr>
<h2 id="🪞-三步反转过程"><a href="#🪞-三步反转过程" class="headerlink" title="🪞 三步反转过程"></a>🪞 三步反转过程</h2><ol>
<li><p><strong>整体反转</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7] → [7,6,5,4,3,2,1]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反转前 k 段（即反转后数组的前 k 个元素）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[7,6,5,4,3,2,1] → [5,6,7,4,3,2,1]</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>反转剩下的部分（即后 n-k 个元素）</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5,6,7,4,3,2,1] → [5,6,7,1,2,3,4]</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这样就得到了正确的轮转结果。</p>
<h3 id="这题的思路很巧妙，很难想到，我如果想做出这道题，我脑子中的分析链条应该是怎么样的呢，我该从哪里切入才能一步一步根据蛛丝马迹嗅到这一巧妙的算法，并且拿着这种思考习惯去思考别的问题，我的意思是我想将这种做算法的思考习惯提炼出一种方法论，以至于我遇见每一个算法题都可以不变应万变，就好比，我是先分析什么？题目要求？空间？O（1）？然后我会去想什么？"><a href="#这题的思路很巧妙，很难想到，我如果想做出这道题，我脑子中的分析链条应该是怎么样的呢，我该从哪里切入才能一步一步根据蛛丝马迹嗅到这一巧妙的算法，并且拿着这种思考习惯去思考别的问题，我的意思是我想将这种做算法的思考习惯提炼出一种方法论，以至于我遇见每一个算法题都可以不变应万变，就好比，我是先分析什么？题目要求？空间？O（1）？然后我会去想什么？" class="headerlink" title="这题的思路很巧妙，很难想到，我如果想做出这道题，我脑子中的分析链条应该是怎么样的呢，我该从哪里切入才能一步一步根据蛛丝马迹嗅到这一巧妙的算法，并且拿着这种思考习惯去思考别的问题，我的意思是我想将这种做算法的思考习惯提炼出一种方法论，以至于我遇见每一个算法题都可以不变应万变，就好比，我是先分析什么？题目要求？空间？O（1）？然后我会去想什么？"></a>这题的思路很巧妙，很难想到，我如果想做出这道题，我脑子中的分析链条应该是怎么样的呢，我该从哪里切入才能一步一步根据蛛丝马迹嗅到这一巧妙的算法，并且拿着这种思考习惯去思考别的问题，我的意思是我想将这种做算法的思考习惯提炼出一种方法论，以至于我遇见每一个算法题都可以不变应万变，就好比，我是先分析什么？题目要求？空间？O（1）？然后我会去想什么？</h3><h6 id="ChatGPT-说："><a href="#ChatGPT-说：" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><h1 id="抽象成方法论：把“看到-→-猜测-→-验证-→-抽象”为可复用的解题链"><a href="#抽象成方法论：把“看到-→-猜测-→-验证-→-抽象”为可复用的解题链" class="headerlink" title="抽象成方法论：把“看到 → 猜测 → 验证 → 抽象”为可复用的解题链"></a>抽象成方法论：把“看到 → 猜测 → 验证 → 抽象”为可复用的解题链</h1><p>很好的问题 — 不只是想会做一道题，而是把<strong>解题的思考习惯</strong>抽成一套可以在不同题上复用的方法论。下面给你一套清晰的「分析链 + 工具箱 + 练习流程」，并用 <code>rotate</code> 题做示范，告诉你在脑子里该怎么一步步推进、哪些“蛛丝马迹”会引导你想到三次反转那种巧妙解法。</p>
<hr>
<h1 id="一条通用的思考链（每题必走的-7-步）"><a href="#一条通用的思考链（每题必走的-7-步）" class="headerlink" title="一条通用的思考链（每题必走的 7 步）"></a>一条通用的思考链（每题必走的 7 步）</h1><ol>
<li><strong>读题并复述目标（What）</strong><ul>
<li>用一句话复述：输入是什么，输出&#x2F;变更是什么（返回新数组？原地修改？打印？）。</li>
<li>例：把数组向右移动 k 位，要求原地 O(1) 额外空间。</li>
</ul>
</li>
<li><strong>确定约束&#x2F;目标（Constraints &amp; Goals）</strong><ul>
<li>n 的大小、时间&#x2F;空间上有没有硬性要求（O(1) 还是允许 O(n)），是否可修改输入，k 边界（k &gt; n）。</li>
<li>例：题目要求原地（O(1) 空间），这极大缩小解法范围。</li>
</ul>
</li>
<li><strong>画小例子 + 手动模拟（Explore examples）</strong><ul>
<li>取最小&#x2F;典型&#x2F;边界例：n&#x3D;1、k&#x3D;0、k&#x3D;1、k&#x3D;n、k&gt;n、奇偶长度等。</li>
<li>在纸上、用数组写出每步变化，寻找可以做的局部操作。</li>
</ul>
</li>
<li><strong>找“不变式 &#x2F; 想达到的局部状态”（Invariant &#x2F; target substructure）</strong><ul>
<li>思考有没有你可以通过局部操作维护或达到的中间形态（例如把后 k 个元素变成前 k 个元素但顺序颠倒）。</li>
<li>例：把后 k 个元素移动到前面是目标；你可以先把整体颠倒，后 k 段会变成数组前段（但顺序反了）——这是关键不变&#x2F;中间态。</li>
</ul>
</li>
<li><strong>联想已知模式与常用手法（Pattern matching）</strong><ul>
<li>列出常见技巧&#x2F;模板：反转、滑动窗口、双指针、快慢指针、异或&#x2F;位运算、哈希表计数、前缀和、动态规划等。</li>
<li>用约束排除不合适的：若空间要求 O(1) → 排除用额外数组&#x2F;哈希的想法。</li>
<li>例：原地 + 子段移动 → 反转&#x2F;交换&#x2F;循环替换 都是常见技术；反转能把段顺序倒置，合并几步可能恢复顺序 → 联想到三次反转。</li>
</ul>
</li>
<li><strong>验证与证明（Prove &#x2F; Dry-run）</strong><ul>
<li>在几个例子上手工验证每步是否把数组推进到正确状态；证明为什么操作数次后能恢复原顺序（不变式证明）。</li>
<li>例：整体反转后再反转前 k 个，再反转后 n−k 个 → 逐步恢复两段原来的顺序并实现拼接。</li>
</ul>
</li>
<li><strong>实现＋优化＋边界处理（Implement &amp; Harden）</strong><ul>
<li>实现时注意取模、边界（k&#x3D;0、k%&#x3D;n、n&#x3D;0 或 n&#x3D;1），写清楚反转函数并注释时间&#x2F;空间复杂度。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="针对-rotate-题：你的脑子里可以怎么走（一步步示例）"><a href="#针对-rotate-题：你的脑子里可以怎么走（一步步示例）" class="headerlink" title="针对 rotate 题：你的脑子里可以怎么走（一步步示例）"></a>针对 rotate 题：你的脑子里可以怎么走（一步步示例）</h1><ol>
<li>读题：把数组右移 k 位，<strong>要求原地</strong>（O(1)）。（<strong>核心线索</strong>：原地 → 不可用额外数组）</li>
<li>约束：k 可能 &gt; n → 马上想到 <code>k %= n</code>（常见小技巧）。</li>
<li>画例子：<ul>
<li><code>[1,2,3,4,5,6,7]</code>, k&#x3D;3 → <code>[5,6,7,1,2,3,4]</code>。</li>
<li>把数组分成两段 <code>[1,2,3,4]</code> 和 <code>[5,6,7]</code>。</li>
</ul>
</li>
<li>问自己：如何<strong>在数组内部</strong>把后半段挪到前面？<ul>
<li>直接一个一个挪会 O(k·n) 或需要额外空间。想要 O(n) 且 O(1) → 需要“整体且局部操作”。</li>
</ul>
</li>
<li>联想到“反转”这个操作：反转是<strong>原地</strong>且能改变顺序的强工具。试着对例子做反转：<ul>
<li>全反 → <code>[7,6,5,4,3,2,1]</code>，现在原来的后半段在前面但顺序反了（<code>7,6,5</code>），对这个片段再反一次能恢复顺序（→ <code>5,6,7</code>）。同理把余下的段反回来。</li>
</ul>
</li>
<li>得到三步反转法并在几个例子验证。</li>
<li>实现并处理 <code>k%=n</code>、<code>k==0</code>、<code>n==1</code> 等边界。</li>
</ol>
<p>关键点在第4步：<strong>把目标分解成更容易实现的“中间状态”</strong>（这里是把“后 k 段在前”这一目标转化为“先整体反转再局部反转”这样更容易的中间状态），这是触发巧妙方法的常见套路。</p>
<hr>
<h1 id="一套可记忆的「触发器（hints）」：看到这些就该想这些技巧"><a href="#一套可记忆的「触发器（hints）」：看到这些就该想这些技巧" class="headerlink" title="一套可记忆的「触发器（hints）」：看到这些就该想这些技巧"></a>一套可记忆的「触发器（hints）」：看到这些就该想这些技巧</h1><ul>
<li>要 <strong>原地 &#x2F; O(1)</strong> + 段操作 → 想：反转 &#x2F; 交换 &#x2F; 三路划分</li>
<li>要 <strong>子串最大&#x2F;最小&#x2F;和</strong> → 想：滑动窗口 &#x2F; 前缀和</li>
<li>要 <strong>子序列&#x2F;子集计数或是否存在</strong> → 想：动态规划 &#x2F; 状态压缩 &#x2F; 位掩码</li>
<li>要 <strong>pair&#x2F;两数问题</strong> → 想：双指针（排序后）或哈希表（无序）</li>
<li>要 <strong>重复&#x2F;出现次数&#x2F;频率</strong> → 想：哈希计数 &#x2F; 排序 &#x2F; 摩尔投票（多数元素）</li>
<li>要 <strong>最优解&#x2F;贪心</strong> → 想：是否存在“局部最优可扩展到全局”且有可交换性</li>
<li>要 <strong>在数组中原地循环移动一些元素</strong> → 想：取模、环形替换（循环替代）或反转<br>把这张清单背一遍，遇到题时迅速对照。</li>
</ul>
<hr>
<h1 id="思考习惯（方法论）——你需要养成的-6-个习惯"><a href="#思考习惯（方法论）——你需要养成的-6-个习惯" class="headerlink" title="思考习惯（方法论）——你需要养成的 6 个习惯"></a>思考习惯（方法论）——你需要养成的 6 个习惯</h1><ol>
<li><strong>先手画例子</strong>（至少 3 个：普通&#x2F;边界&#x2F;极端）——这是最重要的快速检验手段。</li>
<li><strong>立刻写出约束清单</strong>（n、k 范围、是否允许修改输入、是否要求 O(1)）——通过约束缩小搜索空间。</li>
<li><strong>把目标拆成“局部目标”</strong>（中间状态）——很多巧妙解法就是先达成一个“可管理”的中间形态。</li>
<li><strong>常用模板速查</strong>（把上面的触发器做成短卡片）——做题前先在脑中刷一遍模板。</li>
<li><strong>时间空间权衡</strong>：问自己“可以用额外空间吗？”如果不可以，就立刻排除很多直观方法。</li>
<li><strong>把解法口述一遍并证明不变式</strong>（2–3 句）——能口述清楚的解法，通常就是正确且可复现的。</li>
</ol>
<hr>
<h1 id="练习计划（把习惯变成长期能力）"><a href="#练习计划（把习惯变成长期能力）" class="headerlink" title="练习计划（把习惯变成长期能力）"></a>练习计划（把习惯变成长期能力）</h1><ul>
<li>每周 3 题：分别从数组、字符串、DP、贪心、图&#x2F;树 中各挑 1 题练习。</li>
<li>做题流程固定化（用上面的 7 步）：读题→约束→例子→触发器→尝试→验证→实现。</li>
<li>专项训练：挑 10 道「原地&#x2F;空间受限」的题，把你想到的每种可能都写出来并用约束排除。</li>
<li>复盘：每做完一题写 3 行复盘笔记：关键触发点、为什么想到该模板、可推广的模式。</li>
<li>模式卡片：把“触发器”做成 1 页卡片，遇题先过一遍卡片（20–30 秒），形成条件-技巧的快速映射。</li>
</ul>
<hr>
<h1 id="给你的心智模型（一句话版）"><a href="#给你的心智模型（一句话版）" class="headerlink" title="给你的心智模型（一句话版）"></a>给你的心智模型（一句话版）</h1><p>从“目标 → 约束 → 小例子”出发，寻找能在<strong>原地改变顺序</strong>或<strong>维护不变式</strong>的基本操作（反转、交换、双指针、哈希、前缀），把大问题拆成能用这些基本操作完成的中间状态，然后验证。</p>
<hr>
<p>如果你愿意，我可以：</p>
<ul>
<li>把上面的触发器做成一页可打印的“题型-技巧”速查表；或</li>
<li>针对你当前水平出 8 道练习题（含难度分布）并给每题的快速触发器提示，帮助你把方法论落到实处。</li>
</ul>
<p>你想先要哪一个？</p>
<h5 id="你说："><a href="#你说：" class="headerlink" title="你说："></a>你说：</h5><h3 id="找“不变式-想达到的局部状态”（Invariant-target-substructure）-思考有没有你可以通过局部操作维护或达到的中间形态（例如把后-k-个元素变成前-k-个元素但顺序颠倒）。-例：把后-k-个元素移动到前面是目标；你可以先把整体颠倒，后-k-段会变成数组前段（但顺序反了）——这是关键不变-中间态。这里这一步是最难的，很多时候我总是想着最终的目标，但是困难的目标往往有很多“中间态”需要我去实现，想出这个中间态才是解决巧妙算法的精髓，这很难，我该怎么才能想到中间态呢"><a href="#找“不变式-想达到的局部状态”（Invariant-target-substructure）-思考有没有你可以通过局部操作维护或达到的中间形态（例如把后-k-个元素变成前-k-个元素但顺序颠倒）。-例：把后-k-个元素移动到前面是目标；你可以先把整体颠倒，后-k-段会变成数组前段（但顺序反了）——这是关键不变-中间态。这里这一步是最难的，很多时候我总是想着最终的目标，但是困难的目标往往有很多“中间态”需要我去实现，想出这个中间态才是解决巧妙算法的精髓，这很难，我该怎么才能想到中间态呢" class="headerlink" title="找“不变式 &#x2F; 想达到的局部状态”（Invariant &#x2F; target substructure） 思考有没有你可以通过局部操作维护或达到的中间形态（例如把后 k 个元素变成前 k 个元素但顺序颠倒）。 例：把后 k 个元素移动到前面是目标；你可以先把整体颠倒，后 k 段会变成数组前段（但顺序反了）——这是关键不变&#x2F;中间态。这里这一步是最难的，很多时候我总是想着最终的目标，但是困难的目标往往有很多“中间态”需要我去实现，想出这个中间态才是解决巧妙算法的精髓，这很难，我该怎么才能想到中间态呢"></a>找“不变式 &#x2F; 想达到的局部状态”（Invariant &#x2F; target substructure） 思考有没有你可以通过局部操作维护或达到的中间形态（例如把后 k 个元素变成前 k 个元素但顺序颠倒）。 例：把后 k 个元素移动到前面是目标；你可以先把整体颠倒，后 k 段会变成数组前段（但顺序反了）——这是关键不变&#x2F;中间态。这里这一步是最难的，很多时候我总是想着最终的目标，但是困难的目标往往有很多“中间态”需要我去实现，想出这个中间态才是解决巧妙算法的精髓，这很难，我该怎么才能想到中间态呢</h3><h6 id="ChatGPT-说：-1"><a href="#ChatGPT-说：-1" class="headerlink" title="ChatGPT 说："></a>ChatGPT 说：</h6><p>非常棒的洞察👏——你抓到了算法思维中最本质、最“会者不难”的一点：</p>
<blockquote>
<p><strong>真正的难点不是想到答案，而是想到「中间态」。</strong></p>
</blockquote>
<p>几乎所有巧妙的算法，都是在某个困难目标和直接做不到的局面之间，插入一个“可操作的中间态（中转站）”。<br> 我们来系统讲讲——<strong>如何“看见”中间态。</strong></p>
<hr>
<h2 id="🌱-一、什么是中间态？（核心定义）"><a href="#🌱-一、什么是中间态？（核心定义）" class="headerlink" title="🌱 一、什么是中间态？（核心定义）"></a>🌱 一、什么是中间态？（核心定义）</h2><blockquote>
<p><strong>中间态 &#x3D; 比目标更容易实现，又能一步步过渡到目标的局部结构。</strong></p>
</blockquote>
<p>它满足两点：</p>
<ol>
<li>你能用已有的工具或操作“轻易做到它”；</li>
<li>达到它之后，剩下的部分更容易继续推到目标。</li>
</ol>
<p>例子（轮转数组）：</p>
<ul>
<li>目标：把后 k 段搬到前面。</li>
<li>难点：如何原地移动一整段？</li>
<li>可行操作：反转（我们能轻松原地反转数组）。</li>
<li>那就问：如果我反转整个数组，会发生什么？<br>👉 “后半段跑到前面了，但顺序错了” → 这正是一个有价值的中间态！</li>
</ul>
<hr>
<h2 id="🧭-二、找到中间态的五种思维路径"><a href="#🧭-二、找到中间态的五种思维路径" class="headerlink" title="🧭 二、找到中间态的五种思维路径"></a>🧭 二、找到中间态的<strong>五种思维路径</strong></h2><p>当你卡在“直接达不到目标”时，就从下面 5 种角度去“嗅”中间态。</p>
<hr>
<h3 id="🧩-1-反向思考：从目标往前推"><a href="#🧩-1-反向思考：从目标往前推" class="headerlink" title="🧩 1. 反向思考：从目标往前推"></a>🧩 1. <strong>反向思考：从目标往前推</strong></h3><p>问自己：“要达到这个目标，最后一步必须是什么？”<br> 这最后一步，往往暗示了中间态。</p>
<p>例：<br> “数组要被右移 k 位”<br> → 最后一刻，一定是“右边的元素出现在前面”。<br> → 那么在倒数第二步，它们可能已经在前面，只是顺序颠倒。<br> → 反转就是可行操作。<br> → 找到了中间态：<strong>“后半段在前，但顺序反了”</strong>。</p>
<p>✅ 技巧：想象“倒放视频”，逆推每个操作，找能反转的结构。</p>
<hr>
<h3 id="🔄-2-聚焦可操作的原子动作"><a href="#🔄-2-聚焦可操作的原子动作" class="headerlink" title="🔄 2. 聚焦可操作的原子动作"></a>🔄 2. <strong>聚焦可操作的原子动作</strong></h3><p>直接问自己：“我能在 O(1) 空间内做哪些操作？”<br> → “交换”、“反转”、“滑动窗口”、“异或”等。<br> 这些是你手上的“操作积木”。<br> 目标做不到没关系，想想这些积木组合后能造出什么结构。</p>
<p>例（rotate）：</p>
<ul>
<li>我能做的：swap、reverse</li>
<li>reverse 会让后段跑到前面但顺序颠倒</li>
<li>swap 也能局部交换段 → 可以造中间态。</li>
</ul>
<p>✅ 技巧：<strong>先列可做的原子操作</strong>，再问它们能改变什么维度（顺序、位置、状态）。</p>
<hr>
<h3 id="🪞-3-引入对称性（symmetry）或不变式（invariant）"><a href="#🪞-3-引入对称性（symmetry）或不变式（invariant）" class="headerlink" title="🪞 3. 引入对称性（symmetry）或不变式（invariant）"></a>🪞 3. <strong>引入对称性（symmetry）或不变式（invariant）</strong></h3><p>问：“这个问题里有什么结构不变？我能利用它吗？”</p>
<p>例：</p>
<ul>
<li>数组长度不变、元素总集不变。</li>
<li>我只改变“顺序”。</li>
<li>那我能用“对称操作”反转顺序。</li>
</ul>
<p>反转就是一种保持集合内容但改变顺序的对称操作。<br> 利用不变的部分（内容不变）去操作变化的部分（顺序），<br> → 就自然导出“反转”这种中间形态。</p>
<p>✅ 技巧：<strong>固定一部分，看能否在保持不变的条件下改变另一部分。</strong></p>
<hr>
<h3 id="🔍-4-局部实验：暴力思考简化例子"><a href="#🔍-4-局部实验：暴力思考简化例子" class="headerlink" title="🔍 4. 局部实验：暴力思考简化例子"></a>🔍 4. <strong>局部实验：暴力思考简化例子</strong></h3><p>拿一个极小的输入，在纸上试几步。<br> 你会发现某些中间形态会<strong>重复出现</strong>。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[1,2,3,4,5,6,7], k=3</span><br><span class="line">目标: [5,6,7,1,2,3,4]</span><br><span class="line">尝试反转整体 → [7,6,5,4,3,2,1]</span><br><span class="line">此时后k段(5,6,7)在前，但反了</span><br><span class="line">→ 灵感出现：能不能反转回去？</span><br></pre></td></tr></table></figure>

<p>✅ 技巧：<strong>用小例子玩出“局部对称性”</strong>，很多中间态会自然显形。</p>
<hr>
<h3 id="🧠-5-类比（Analogy）与“操作迁移”"><a href="#🧠-5-类比（Analogy）与“操作迁移”" class="headerlink" title="🧠 5. 类比（Analogy）与“操作迁移”"></a>🧠 5. <strong>类比（Analogy）与“操作迁移”</strong></h3><p>问自己：“我做过类似目标但更简单的问题吗？”<br> 把你以前成功的操作迁移过来。</p>
<p>例：</p>
<ul>
<li>字符串反转 → 也是在原地颠倒顺序。</li>
<li>如果能原地反转字符串，也能原地反转数组。</li>
<li>于是轮转问题 → “部分反转”问题。</li>
</ul>
<p>✅ 技巧：建立“动作模板库”。<br> 每次遇新题，就去匹配你脑中旧的可操作模式（反转、双指针、前缀和、排序、堆…）。</p>
<hr>
<h2 id="⚙️-三、形成“中间态敏感度”的训练法"><a href="#⚙️-三、形成“中间态敏感度”的训练法" class="headerlink" title="⚙️ 三、形成“中间态敏感度”的训练法"></a>⚙️ 三、形成“中间态敏感度”的训练法</h2><ol>
<li><strong>把每道题拆成两层</strong><ul>
<li>上层：最终目标</li>
<li>下层：你能直接操作的东西<br>每次遇到卡壳，就问：“能否造个中转层（让上层通过下层实现）？”</li>
</ul>
</li>
<li><strong>每日练 1 题 + “中间态追问”</strong><br>做题时，不急着看答案，问自己：<ul>
<li>“直接做不到目标，我能先让结构变成什么样？”</li>
<li>“这一步后，我的目标是否变简单了？”</li>
<li>“我手里能做的操作有哪些？”<br>这三个问题能帮你自动搜寻中间态。</li>
</ul>
</li>
<li><strong>复盘：写下“那个关键中间态”</strong><br>不总结整个解法，只总结「我发现的中间态是什么、它帮我解题的关键点是什么」。</li>
<li><strong>对比同类题</strong><br>例如：<ul>
<li>旋转数组、反转字符串、翻转链表（都是「顺序重排」问题）</li>
<li>都可以用「反转局部 → 达成全局」思路<br>这样中间态就会自然成为模板。</li>
</ul>
</li>
</ol>
<hr>
<h2 id="🌟-你可以内化的思考模板（总结一句话）"><a href="#🌟-你可以内化的思考模板（总结一句话）" class="headerlink" title="🌟 你可以内化的思考模板（总结一句话）"></a>🌟 你可以内化的思考模板（总结一句话）</h2><blockquote>
<p>当目标难以直接实现时，不要想着“一步到位”，而要<strong>问自己能不能通过某个简单的、可操作的局部变换</strong>，<br>让问题“变得更像你已经会的问题”。</p>
</blockquote>
<h2 id="所以说想要解决一个最终的目标，往往需要找到中间态去解决，就像要实现一个大目标，就要拆成一点点逼近的小目标，把问题慢慢变成自己一眼就能解决的小问题，而解决这些小问题往往才会需要那些条件反射的需要积累的小方法和经典算法了，这时候才会使用平常学习的一些简单的东西"><a href="#所以说想要解决一个最终的目标，往往需要找到中间态去解决，就像要实现一个大目标，就要拆成一点点逼近的小目标，把问题慢慢变成自己一眼就能解决的小问题，而解决这些小问题往往才会需要那些条件反射的需要积累的小方法和经典算法了，这时候才会使用平常学习的一些简单的东西" class="headerlink" title="所以说想要解决一个最终的目标，往往需要找到中间态去解决，就像要实现一个大目标，就要拆成一点点逼近的小目标，把问题慢慢变成自己一眼就能解决的小问题，而解决这些小问题往往才会需要那些条件反射的需要积累的小方法和经典算法了，这时候才会使用平常学习的一些简单的东西"></a>所以说想要解决一个最终的目标，往往需要找到中间态去解决，就像要实现一个大目标，就要拆成一点点逼近的小目标，把问题慢慢变成自己一眼就能解决的小问题，而解决这些小问题往往才会需要那些条件反射的需要积累的小方法和经典算法了，这时候才会使用平常学习的一些简单的东西</h2></article><!-- lincense--><div class="license-wrapper"><p> <span>Author:  </span><a href="http://example.com">chenjunda</a></p><p> <span>Link:  </span><a href="http://example.com/2025/11/05/189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/">http://example.com/2025/11/05/189-%E8%BD%AE%E8%BD%AC%E6%95%B0%E7%BB%84/</a></p><p> <span>Copyright:  </span><span>All articles in this blog are licensed under <a rel="license noopener" target="_blank" href="https://creativecommons.org/licenses/by-nc-nd/3.0">CC BY-NC-SA 3.0</a> unless stating additionally.</span></p></div><div class="post-paginator"><a class="prevSlogan" href="/2025/11/05/41-%E7%BC%BA%E5%A4%B1%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%AD%A3%E6%95%B0/" title="41.缺失的第一个正数"><span>< PreviousPost</span><br><span class="prevTitle">41.缺失的第一个正数</span></a><a class="nextSlogan" href="/2025/11/05/diary2025-10-29/" title="diary2025-10-29"><span>NextPost ></span><br><span class="nextTitle">diary2025-10-29</span></a><div class="clear"></div></div><div id="comment"></div></section></article><footer id="cxo-footer-outer"><div id="cxo-footer-inner"><p class="footer-container"><span>Site by </span><a target="_blank" rel="noopener" href="http://hexo.io"><span>Hexo</span></a><span> | theme </span><a target="_blank" rel="noopener" href="https://github.com/Longlongyu/hexo-theme-Cxo"><span>Cxo</span></a></p><i class="fa fa-user"> </i><span id="busuanzi_value_site_uv"></span><span> | </span><i class="fa fa-eye"> </i><span id="busuanzi_value_site_pv"></span></div></footer><!-- catelog--><div class="toc-wrapper" style="top: 70vh;"><div class="toc-catalog"><i class="fa fa-list"> </i><span>CATALOG</span></div><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%92%A1-%E6%80%9D%E8%B7%AF%E6%A0%B8%E5%BF%83%EF%BC%9A%E4%B8%89%E6%AC%A1%E5%8F%8D%E8%BD%AC%E6%B3%95%EF%BC%88Reverse-Algorithm%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">💡 思路核心：三次反转法（Reverse Algorithm）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%AA%9E-%E4%B8%89%E6%AD%A5%E5%8F%8D%E8%BD%AC%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">🪞 三步反转过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%99%E9%A2%98%E7%9A%84%E6%80%9D%E8%B7%AF%E5%BE%88%E5%B7%A7%E5%A6%99%EF%BC%8C%E5%BE%88%E9%9A%BE%E6%83%B3%E5%88%B0%EF%BC%8C%E6%88%91%E5%A6%82%E6%9E%9C%E6%83%B3%E5%81%9A%E5%87%BA%E8%BF%99%E9%81%93%E9%A2%98%EF%BC%8C%E6%88%91%E8%84%91%E5%AD%90%E4%B8%AD%E7%9A%84%E5%88%86%E6%9E%90%E9%93%BE%E6%9D%A1%E5%BA%94%E8%AF%A5%E6%98%AF%E6%80%8E%E4%B9%88%E6%A0%B7%E7%9A%84%E5%91%A2%EF%BC%8C%E6%88%91%E8%AF%A5%E4%BB%8E%E5%93%AA%E9%87%8C%E5%88%87%E5%85%A5%E6%89%8D%E8%83%BD%E4%B8%80%E6%AD%A5%E4%B8%80%E6%AD%A5%E6%A0%B9%E6%8D%AE%E8%9B%9B%E4%B8%9D%E9%A9%AC%E8%BF%B9%E5%97%85%E5%88%B0%E8%BF%99%E4%B8%80%E5%B7%A7%E5%A6%99%E7%9A%84%E7%AE%97%E6%B3%95%EF%BC%8C%E5%B9%B6%E4%B8%94%E6%8B%BF%E7%9D%80%E8%BF%99%E7%A7%8D%E6%80%9D%E8%80%83%E4%B9%A0%E6%83%AF%E5%8E%BB%E6%80%9D%E8%80%83%E5%88%AB%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%8C%E6%88%91%E7%9A%84%E6%84%8F%E6%80%9D%E6%98%AF%E6%88%91%E6%83%B3%E5%B0%86%E8%BF%99%E7%A7%8D%E5%81%9A%E7%AE%97%E6%B3%95%E7%9A%84%E6%80%9D%E8%80%83%E4%B9%A0%E6%83%AF%E6%8F%90%E7%82%BC%E5%87%BA%E4%B8%80%E7%A7%8D%E6%96%B9%E6%B3%95%E8%AE%BA%EF%BC%8C%E4%BB%A5%E8%87%B3%E4%BA%8E%E6%88%91%E9%81%87%E8%A7%81%E6%AF%8F%E4%B8%80%E4%B8%AA%E7%AE%97%E6%B3%95%E9%A2%98%E9%83%BD%E5%8F%AF%E4%BB%A5%E4%B8%8D%E5%8F%98%E5%BA%94%E4%B8%87%E5%8F%98%EF%BC%8C%E5%B0%B1%E5%A5%BD%E6%AF%94%EF%BC%8C%E6%88%91%E6%98%AF%E5%85%88%E5%88%86%E6%9E%90%E4%BB%80%E4%B9%88%EF%BC%9F%E9%A2%98%E7%9B%AE%E8%A6%81%E6%B1%82%EF%BC%9F%E7%A9%BA%E9%97%B4%EF%BC%9FO%EF%BC%881%EF%BC%89%EF%BC%9F%E7%84%B6%E5%90%8E%E6%88%91%E4%BC%9A%E5%8E%BB%E6%83%B3%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">2.1.</span> <span class="toc-text">这题的思路很巧妙，很难想到，我如果想做出这道题，我脑子中的分析链条应该是怎么样的呢，我该从哪里切入才能一步一步根据蛛丝马迹嗅到这一巧妙的算法，并且拿着这种思考习惯去思考别的问题，我的意思是我想将这种做算法的思考习惯提炼出一种方法论，以至于我遇见每一个算法题都可以不变应万变，就好比，我是先分析什么？题目要求？空间？O（1）？然后我会去想什么？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ChatGPT-%E8%AF%B4%EF%BC%9A"><span class="toc-number">2.1.0.0.1.</span> <span class="toc-text">ChatGPT 说：</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%88%90%E6%96%B9%E6%B3%95%E8%AE%BA%EF%BC%9A%E6%8A%8A%E2%80%9C%E7%9C%8B%E5%88%B0-%E2%86%92-%E7%8C%9C%E6%B5%8B-%E2%86%92-%E9%AA%8C%E8%AF%81-%E2%86%92-%E6%8A%BD%E8%B1%A1%E2%80%9D%E4%B8%BA%E5%8F%AF%E5%A4%8D%E7%94%A8%E7%9A%84%E8%A7%A3%E9%A2%98%E9%93%BE"><span class="toc-number"></span> <span class="toc-text">抽象成方法论：把“看到 → 猜测 → 验证 → 抽象”为可复用的解题链</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E6%9D%A1%E9%80%9A%E7%94%A8%E7%9A%84%E6%80%9D%E8%80%83%E9%93%BE%EF%BC%88%E6%AF%8F%E9%A2%98%E5%BF%85%E8%B5%B0%E7%9A%84-7-%E6%AD%A5%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">一条通用的思考链（每题必走的 7 步）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%92%88%E5%AF%B9-rotate-%E9%A2%98%EF%BC%9A%E4%BD%A0%E7%9A%84%E8%84%91%E5%AD%90%E9%87%8C%E5%8F%AF%E4%BB%A5%E6%80%8E%E4%B9%88%E8%B5%B0%EF%BC%88%E4%B8%80%E6%AD%A5%E6%AD%A5%E7%A4%BA%E4%BE%8B%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">针对 rotate 题：你的脑子里可以怎么走（一步步示例）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E5%A5%97%E5%8F%AF%E8%AE%B0%E5%BF%86%E7%9A%84%E3%80%8C%E8%A7%A6%E5%8F%91%E5%99%A8%EF%BC%88hints%EF%BC%89%E3%80%8D%EF%BC%9A%E7%9C%8B%E5%88%B0%E8%BF%99%E4%BA%9B%E5%B0%B1%E8%AF%A5%E6%83%B3%E8%BF%99%E4%BA%9B%E6%8A%80%E5%B7%A7"><span class="toc-number"></span> <span class="toc-text">一套可记忆的「触发器（hints）」：看到这些就该想这些技巧</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%80%9D%E8%80%83%E4%B9%A0%E6%83%AF%EF%BC%88%E6%96%B9%E6%B3%95%E8%AE%BA%EF%BC%89%E2%80%94%E2%80%94%E4%BD%A0%E9%9C%80%E8%A6%81%E5%85%BB%E6%88%90%E7%9A%84-6-%E4%B8%AA%E4%B9%A0%E6%83%AF"><span class="toc-number"></span> <span class="toc-text">思考习惯（方法论）——你需要养成的 6 个习惯</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%83%E4%B9%A0%E8%AE%A1%E5%88%92%EF%BC%88%E6%8A%8A%E4%B9%A0%E6%83%AF%E5%8F%98%E6%88%90%E9%95%BF%E6%9C%9F%E8%83%BD%E5%8A%9B%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">练习计划（把习惯变成长期能力）</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%99%E4%BD%A0%E7%9A%84%E5%BF%83%E6%99%BA%E6%A8%A1%E5%9E%8B%EF%BC%88%E4%B8%80%E5%8F%A5%E8%AF%9D%E7%89%88%EF%BC%89"><span class="toc-number"></span> <span class="toc-text">给你的心智模型（一句话版）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BD%A0%E8%AF%B4%EF%BC%9A"><span class="toc-number">0.0.0.1.</span> <span class="toc-text">你说：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%BE%E2%80%9C%E4%B8%8D%E5%8F%98%E5%BC%8F-%E6%83%B3%E8%BE%BE%E5%88%B0%E7%9A%84%E5%B1%80%E9%83%A8%E7%8A%B6%E6%80%81%E2%80%9D%EF%BC%88Invariant-target-substructure%EF%BC%89-%E6%80%9D%E8%80%83%E6%9C%89%E6%B2%A1%E6%9C%89%E4%BD%A0%E5%8F%AF%E4%BB%A5%E9%80%9A%E8%BF%87%E5%B1%80%E9%83%A8%E6%93%8D%E4%BD%9C%E7%BB%B4%E6%8A%A4%E6%88%96%E8%BE%BE%E5%88%B0%E7%9A%84%E4%B8%AD%E9%97%B4%E5%BD%A2%E6%80%81%EF%BC%88%E4%BE%8B%E5%A6%82%E6%8A%8A%E5%90%8E-k-%E4%B8%AA%E5%85%83%E7%B4%A0%E5%8F%98%E6%88%90%E5%89%8D-k-%E4%B8%AA%E5%85%83%E7%B4%A0%E4%BD%86%E9%A1%BA%E5%BA%8F%E9%A2%A0%E5%80%92%EF%BC%89%E3%80%82-%E4%BE%8B%EF%BC%9A%E6%8A%8A%E5%90%8E-k-%E4%B8%AA%E5%85%83%E7%B4%A0%E7%A7%BB%E5%8A%A8%E5%88%B0%E5%89%8D%E9%9D%A2%E6%98%AF%E7%9B%AE%E6%A0%87%EF%BC%9B%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%85%88%E6%8A%8A%E6%95%B4%E4%BD%93%E9%A2%A0%E5%80%92%EF%BC%8C%E5%90%8E-k-%E6%AE%B5%E4%BC%9A%E5%8F%98%E6%88%90%E6%95%B0%E7%BB%84%E5%89%8D%E6%AE%B5%EF%BC%88%E4%BD%86%E9%A1%BA%E5%BA%8F%E5%8F%8D%E4%BA%86%EF%BC%89%E2%80%94%E2%80%94%E8%BF%99%E6%98%AF%E5%85%B3%E9%94%AE%E4%B8%8D%E5%8F%98-%E4%B8%AD%E9%97%B4%E6%80%81%E3%80%82%E8%BF%99%E9%87%8C%E8%BF%99%E4%B8%80%E6%AD%A5%E6%98%AF%E6%9C%80%E9%9A%BE%E7%9A%84%EF%BC%8C%E5%BE%88%E5%A4%9A%E6%97%B6%E5%80%99%E6%88%91%E6%80%BB%E6%98%AF%E6%83%B3%E7%9D%80%E6%9C%80%E7%BB%88%E7%9A%84%E7%9B%AE%E6%A0%87%EF%BC%8C%E4%BD%86%E6%98%AF%E5%9B%B0%E9%9A%BE%E7%9A%84%E7%9B%AE%E6%A0%87%E5%BE%80%E5%BE%80%E6%9C%89%E5%BE%88%E5%A4%9A%E2%80%9C%E4%B8%AD%E9%97%B4%E6%80%81%E2%80%9D%E9%9C%80%E8%A6%81%E6%88%91%E5%8E%BB%E5%AE%9E%E7%8E%B0%EF%BC%8C%E6%83%B3%E5%87%BA%E8%BF%99%E4%B8%AA%E4%B8%AD%E9%97%B4%E6%80%81%E6%89%8D%E6%98%AF%E8%A7%A3%E5%86%B3%E5%B7%A7%E5%A6%99%E7%AE%97%E6%B3%95%E7%9A%84%E7%B2%BE%E9%AB%93%EF%BC%8C%E8%BF%99%E5%BE%88%E9%9A%BE%EF%BC%8C%E6%88%91%E8%AF%A5%E6%80%8E%E4%B9%88%E6%89%8D%E8%83%BD%E6%83%B3%E5%88%B0%E4%B8%AD%E9%97%B4%E6%80%81%E5%91%A2"><span class="toc-number">0.1.</span> <span class="toc-text">找“不变式 &#x2F; 想达到的局部状态”（Invariant &#x2F; target substructure） 思考有没有你可以通过局部操作维护或达到的中间形态（例如把后 k 个元素变成前 k 个元素但顺序颠倒）。 例：把后 k 个元素移动到前面是目标；你可以先把整体颠倒，后 k 段会变成数组前段（但顺序反了）——这是关键不变&#x2F;中间态。这里这一步是最难的，很多时候我总是想着最终的目标，但是困难的目标往往有很多“中间态”需要我去实现，想出这个中间态才是解决巧妙算法的精髓，这很难，我该怎么才能想到中间态呢</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#ChatGPT-%E8%AF%B4%EF%BC%9A-1"><span class="toc-number">0.1.0.0.1.</span> <span class="toc-text">ChatGPT 说：</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8C%B1-%E4%B8%80%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%AD%E9%97%B4%E6%80%81%EF%BC%9F%EF%BC%88%E6%A0%B8%E5%BF%83%E5%AE%9A%E4%B9%89%EF%BC%89"><span class="toc-number">1.</span> <span class="toc-text">🌱 一、什么是中间态？（核心定义）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%A7%AD-%E4%BA%8C%E3%80%81%E6%89%BE%E5%88%B0%E4%B8%AD%E9%97%B4%E6%80%81%E7%9A%84%E4%BA%94%E7%A7%8D%E6%80%9D%E7%BB%B4%E8%B7%AF%E5%BE%84"><span class="toc-number">2.</span> <span class="toc-text">🧭 二、找到中间态的五种思维路径</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A9-1-%E5%8F%8D%E5%90%91%E6%80%9D%E8%80%83%EF%BC%9A%E4%BB%8E%E7%9B%AE%E6%A0%87%E5%BE%80%E5%89%8D%E6%8E%A8"><span class="toc-number">2.1.</span> <span class="toc-text">🧩 1. 反向思考：从目标往前推</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%84-2-%E8%81%9A%E7%84%A6%E5%8F%AF%E6%93%8D%E4%BD%9C%E7%9A%84%E5%8E%9F%E5%AD%90%E5%8A%A8%E4%BD%9C"><span class="toc-number">2.2.</span> <span class="toc-text">🔄 2. 聚焦可操作的原子动作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%AA%9E-3-%E5%BC%95%E5%85%A5%E5%AF%B9%E7%A7%B0%E6%80%A7%EF%BC%88symmetry%EF%BC%89%E6%88%96%E4%B8%8D%E5%8F%98%E5%BC%8F%EF%BC%88invariant%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">🪞 3. 引入对称性（symmetry）或不变式（invariant）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%94%8D-4-%E5%B1%80%E9%83%A8%E5%AE%9E%E9%AA%8C%EF%BC%9A%E6%9A%B4%E5%8A%9B%E6%80%9D%E8%80%83%E7%AE%80%E5%8C%96%E4%BE%8B%E5%AD%90"><span class="toc-number">2.4.</span> <span class="toc-text">🔍 4. 局部实验：暴力思考简化例子</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%F0%9F%A7%A0-5-%E7%B1%BB%E6%AF%94%EF%BC%88Analogy%EF%BC%89%E4%B8%8E%E2%80%9C%E6%93%8D%E4%BD%9C%E8%BF%81%E7%A7%BB%E2%80%9D"><span class="toc-number">2.5.</span> <span class="toc-text">🧠 5. 类比（Analogy）与“操作迁移”</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E2%9A%99%EF%B8%8F-%E4%B8%89%E3%80%81%E5%BD%A2%E6%88%90%E2%80%9C%E4%B8%AD%E9%97%B4%E6%80%81%E6%95%8F%E6%84%9F%E5%BA%A6%E2%80%9D%E7%9A%84%E8%AE%AD%E7%BB%83%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">⚙️ 三、形成“中间态敏感度”的训练法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%F0%9F%8C%9F-%E4%BD%A0%E5%8F%AF%E4%BB%A5%E5%86%85%E5%8C%96%E7%9A%84%E6%80%9D%E8%80%83%E6%A8%A1%E6%9D%BF%EF%BC%88%E6%80%BB%E7%BB%93%E4%B8%80%E5%8F%A5%E8%AF%9D%EF%BC%89"><span class="toc-number">4.</span> <span class="toc-text">🌟 你可以内化的思考模板（总结一句话）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%80%E4%BB%A5%E8%AF%B4%E6%83%B3%E8%A6%81%E8%A7%A3%E5%86%B3%E4%B8%80%E4%B8%AA%E6%9C%80%E7%BB%88%E7%9A%84%E7%9B%AE%E6%A0%87%EF%BC%8C%E5%BE%80%E5%BE%80%E9%9C%80%E8%A6%81%E6%89%BE%E5%88%B0%E4%B8%AD%E9%97%B4%E6%80%81%E5%8E%BB%E8%A7%A3%E5%86%B3%EF%BC%8C%E5%B0%B1%E5%83%8F%E8%A6%81%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%A4%A7%E7%9B%AE%E6%A0%87%EF%BC%8C%E5%B0%B1%E8%A6%81%E6%8B%86%E6%88%90%E4%B8%80%E7%82%B9%E7%82%B9%E9%80%BC%E8%BF%91%E7%9A%84%E5%B0%8F%E7%9B%AE%E6%A0%87%EF%BC%8C%E6%8A%8A%E9%97%AE%E9%A2%98%E6%85%A2%E6%85%A2%E5%8F%98%E6%88%90%E8%87%AA%E5%B7%B1%E4%B8%80%E7%9C%BC%E5%B0%B1%E8%83%BD%E8%A7%A3%E5%86%B3%E7%9A%84%E5%B0%8F%E9%97%AE%E9%A2%98%EF%BC%8C%E8%80%8C%E8%A7%A3%E5%86%B3%E8%BF%99%E4%BA%9B%E5%B0%8F%E9%97%AE%E9%A2%98%E5%BE%80%E5%BE%80%E6%89%8D%E4%BC%9A%E9%9C%80%E8%A6%81%E9%82%A3%E4%BA%9B%E6%9D%A1%E4%BB%B6%E5%8F%8D%E5%B0%84%E7%9A%84%E9%9C%80%E8%A6%81%E7%A7%AF%E7%B4%AF%E7%9A%84%E5%B0%8F%E6%96%B9%E6%B3%95%E5%92%8C%E7%BB%8F%E5%85%B8%E7%AE%97%E6%B3%95%E4%BA%86%EF%BC%8C%E8%BF%99%E6%97%B6%E5%80%99%E6%89%8D%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%B9%B3%E5%B8%B8%E5%AD%A6%E4%B9%A0%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%9C%E8%A5%BF"><span class="toc-number">5.</span> <span class="toc-text">所以说想要解决一个最终的目标，往往需要找到中间态去解决，就像要实现一个大目标，就要拆成一点点逼近的小目标，把问题慢慢变成自己一眼就能解决的小问题，而解决这些小问题往往才会需要那些条件反射的需要积累的小方法和经典算法了，这时候才会使用平常学习的一些简单的东西</span></a></li></ol></div><!-- top--><i class="fa fa-arrow-up close" id="go-up" aria-hidden="true"></i></body></html>